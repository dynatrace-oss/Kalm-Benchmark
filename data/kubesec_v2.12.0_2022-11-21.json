[[{"object": "ServiceAccount/res-005-1-default-ephemeral-storage-requests-from-namespace-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/res-005-1-default-ephemeral-storage-requests-from-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-005-1-default-ephemeral-storage-requests-from-namespace.kalm-benchmark", "valid": true, "fileName": "manifests/res-005-1-default-ephemeral-storage-requests-from-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-018-1-default-to-root-user-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-1-default-to-root-user.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-018-1-default-to-root-user.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-1-default-to-root-user.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-001-2-allow-privileged-containers-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-001-2-allow-privileged-containers-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Role/rbac-020-3-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-3-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Namespace/res-009-1-no-resource-quota-applied-to-namespace.res-009-1-no-resource-quota-applied-to-namespace", "valid": true, "fileName": "manifests/res-009-1-no-resource-quota-applied-to-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-009-1-no-resource-quota-applied-to-namespace.res-009-1-no-resource-quota-applied-to-namespace", "valid": true, "fileName": "manifests/res-009-1-no-resource-quota-applied-to-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-009-1-no-resource-quota-applied-to-namespace.res-009-1-no-resource-quota-applied-to-namespace", "valid": true, "fileName": "manifests/res-009-1-no-resource-quota-applied-to-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-009-1-no-resource-quota-applied-to-namespace-filler-dedicated-sa.res-009-1-no-resource-quota-applied-to-namespace", "valid": true, "fileName": "manifests/res-009-1-no-resource-quota-applied-to-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-009-1-no-resource-quota-applied-to-namespace.res-009-1-no-resource-quota-applied-to-namespace", "valid": true, "fileName": "manifests/res-009-1-no-resource-quota-applied-to-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-001-1-allow-privileged-containers.kalm-benchmark", "valid": false, "fileName": "manifests/psp-001-1-allow-privileged-containers.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-021-1-using-sysctl-net.ipv4.tcp-keepalive-time-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-021-1-using-sysctl-net.ipv4.tcp-keepalive-time-c86452e6.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-021-1-using-sysctl-net.ipv4.tcp-keepalive-time.kalm-benchmark", "valid": true, "fileName": "manifests/pod-021-1-using-sysctl-net.ipv4.tcp-keepalive-time-c86452e6.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-020-1-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-1-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-017-5-use-runasnonroot-flag-on-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-5-use-runasnonroot-flag-on-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-5-use-runasnonroot-flag-on-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-5-use-runasnonroot-flag-on-container.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "ClusterRole/rbac-003-4-cluster-all-ns-verbs.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-003-4-cluster-role-use-verb-wildcard.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-007-3-don-t-allow-root-users-in-pods.kalm-benchmark", "valid": false, "fileName": "manifests/psp-007-3-don-t-allow-root-users-in-pods.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-013-4-cluster-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-013-4-cluster-role-destructive.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-014-1-not-configuring-seccomp-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-014-1-not-configuring-seccomp-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-034-1-using-dangerous-capability-all-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-034-1-using-dangerous-capability-all.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-034-1-using-dangerous-capability-all.kalm-benchmark", "valid": true, "fileName": "manifests/pod-034-1-using-dangerous-capability-all.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-024-0-usage-of-bin-bash-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-0-usage-of-bin-bash-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-0-usage-of-bin-bash-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-0-usage-of-bin-bash-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/res-007-3-no-cpu-limits-for-namespace.res-007-3-no-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-3-no-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-007-3-no-cpu-limits-for-namespace.res-007-3-no-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-3-no-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-007-3-no-cpu-limits-for-namespace.res-007-3-no-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-3-no-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-007-3-no-cpu-limits-for-namespace.res-007-3-no-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-3-no-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-007-3-no-cpu-limits-for-namespace-filler-dedicated-sa.res-007-3-no-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-3-no-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-007-3-no-cpu-limits-for-namespace.res-007-3-no-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-3-no-cpu-limits-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/ps-002-using-privilegedpodsecurity-level-is-insecure.ps-002-using-privilegedpodsecurity-level-is-insecure", "valid": true, "fileName": "manifests/ps-002-using-privilegedpodsecurity-level-is-insecure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/ps-002-using-privilegedpodsecurity-level-is-insecure.ps-002-using-privilegedpodsecurity-level-is-insecure", "valid": true, "fileName": "manifests/ps-002-using-privilegedpodsecurity-level-is-insecure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/ps-002-using-privilegedpodsecurity-level-is-insecure.ps-002-using-privilegedpodsecurity-level-is-insecure", "valid": true, "fileName": "manifests/ps-002-using-privilegedpodsecurity-level-is-insecure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/ps-002-using-privilegedpodsecurity-level-is-insecure.ps-002-using-privilegedpodsecurity-level-is-insecure", "valid": true, "fileName": "manifests/ps-002-using-privilegedpodsecurity-level-is-insecure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/ps-002-using-privilegedpodsecurity-level-is-insecure-filler-dedicated-sa.ps-002-using-privilegedpodsecurity-level-is-insecure", "valid": true, "fileName": "manifests/ps-002-using-privilegedpodsecurity-level-is-insecure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/ps-002-using-privilegedpodsecurity-level-is-insecure.ps-002-using-privilegedpodsecurity-level-is-insecure", "valid": true, "fileName": "manifests/ps-002-using-privilegedpodsecurity-level-is-insecure.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-003-2-allow-pods-sharing-hostpid-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-003-2-allow-pods-sharing-hostpid-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-002-6-secret-read-watch.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-002-6-read-access-to-secrets.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-16-using-insecure-capability-setpcap-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-16-using-insecure-capability-setpcap.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-16-using-insecure-capability-setpcap.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-16-using-insecure-capability-setpcap.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-019-4-use-gid-set-in-container-takes-precedence-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-4-use-gid-set-in-container-takes-precedence.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-019-4-use-gid-set-in-container-takes-precedence.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-4-use-gid-set-in-container-takes-precedence.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-010-1-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-1-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-14-using-insecure-capability-setfcap-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-14-using-insecure-capability-setfcap.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-14-using-insecure-capability-setfcap.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-14-using-insecure-capability-setfcap.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "RoleBinding/rbac-007-1-role-binds-default-serviceaccount-rb-rbac-007-1-role-bind-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-007-1-role-binds-default-serviceaccount.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-007-1-role-bind-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-007-1-role-binds-default-serviceaccount.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Namespace/res-008-3-no-default-memory-limits-for-namespace.res-008-3-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-3-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-008-3-no-default-memory-limits-for-namespace.res-008-3-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-3-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-008-3-no-default-memory-limits-for-namespace.res-008-3-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-3-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-008-3-no-default-memory-limits-for-namespace.res-008-3-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-3-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-008-3-no-default-memory-limits-for-namespace-filler-dedicated-sa.res-008-3-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-3-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-008-3-no-default-memory-limits-for-namespace.res-008-3-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-3-no-default-memory-limits-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-010-3-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-3-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-17-using-insecure-capability-setuid-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-17-using-insecure-capability-setuid.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-17-using-insecure-capability-setuid.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-17-using-insecure-capability-setuid.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/res-002-1-default-memory-limits-from-namespace-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/res-002-1-default-memory-limits-from-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-002-1-default-memory-limits-from-namespace.kalm-benchmark", "valid": true, "fileName": "manifests/res-002-1-default-memory-limits-from-namespace.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}]}}], [{"object": "ServiceAccount/res-003-1-default-cpu-requests-from-namespace-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/res-003-1-default-cpu-requests-from-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-003-1-default-cpu-requests-from-namespace.kalm-benchmark", "valid": true, "fileName": "manifests/res-003-1-default-cpu-requests-from-namespace.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-012-not-configuring-se-linux.kalm-benchmark", "valid": false, "fileName": "manifests/psp-012-not-configuring-se-linux.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Namespace/res-007-2-no-default-cpu-limits-for-namespace.res-007-2-no-default-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-2-no-default-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-007-2-no-default-cpu-limits-for-namespace.res-007-2-no-default-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-2-no-default-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-007-2-no-default-cpu-limits-for-namespace.res-007-2-no-default-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-2-no-default-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-007-2-no-default-cpu-limits-for-namespace.res-007-2-no-default-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-2-no-default-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-007-2-no-default-cpu-limits-for-namespace-filler-dedicated-sa.res-007-2-no-default-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-2-no-default-cpu-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-007-2-no-default-cpu-limits-for-namespace.res-007-2-no-default-cpu-limits-for-namespace", "valid": true, "fileName": "manifests/res-007-2-no-default-cpu-limits-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-19-using-insecure-capability-sys-chroot-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-19-using-insecure-capability-sys-chroot.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-19-using-insecure-capability-sys-chroot.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-19-using-insecure-capability-sys-chroot.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-003-2-default-pod-automount-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-2-default-pod-automount-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-2-default-pod-automount-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-2-default-pod-automount-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/np-002-2-only-egress-is-blocked.np-002-2-only-egress-is-blocked", "valid": true, "fileName": "manifests/np-002-2-only-egress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/np-002-2-only-egress-is-blocked.np-002-2-only-egress-is-blocked", "valid": true, "fileName": "manifests/np-002-2-only-egress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/np-002-2-only-egress-is-blocked.np-002-2-only-egress-is-blocked", "valid": true, "fileName": "manifests/np-002-2-only-egress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/np-002-2-only-egress-is-blocked.np-002-2-only-egress-is-blocked", "valid": true, "fileName": "manifests/np-002-2-only-egress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/np-002-2-only-egress-is-blocked-filler-dedicated-sa.np-002-2-only-egress-is-blocked", "valid": true, "fileName": "manifests/np-002-2-only-egress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/np-002-2-only-egress-is-blocked.np-002-2-only-egress-is-blocked", "valid": true, "fileName": "manifests/np-002-2-only-egress-is-blocked.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-010-not-dropping-all-capabilities.kalm-benchmark", "valid": false, "fileName": "manifests/psp-010-not-dropping-all-capabilities.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-017-6-runasnonroot-is-optional-on-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-6-runasnonroot-is-optional-on-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-6-runasnonroot-is-optional-on-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-6-runasnonroot-is-optional-on-container.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "Role/rbac-012-1-role-disclose-info.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-012-1-role-info-disclosure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-6-using-insecure-capability-fsetid-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-6-using-insecure-capability-fsetid.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-6-using-insecure-capability-fsetid.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-6-using-insecure-capability-fsetid.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-024-8-usage-of-usr-bin-busybox-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-8-usage-of-usr-bin-busybox-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-8-usage-of-usr-bin-busybox-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-8-usage-of-usr-bin-busybox-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-008-1-use-no-hostpid-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-008-1-use-no-hostpid.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-008-1-use-no-hostpid.kalm-benchmark", "valid": true, "fileName": "manifests/pod-008-1-use-no-hostpid.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/rel-002-no-livenessprobe-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rel-002-no-livenessprobe.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/rel-002-no-livenessprobe.kalm-benchmark", "valid": true, "fileName": "manifests/rel-002-no-livenessprobe.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-017-9-set-runasnonroot-not-correctly-on-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-9-set-runasnonroot-not-correctly-on-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-9-set-runasnonroot-not-correctly-on-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-9-set-runasnonroot-not-correctly-on-container.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "ServiceAccount/pod-042-1-volume-with-read-only-hostpath-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-042-1-volume-with-read-only-hostpath.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-042-1-volume-with-read-only-hostpath.kalm-benchmark", "valid": true, "fileName": "manifests/pod-042-1-volume-with-read-only-hostpath.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/rbac-016-ronin-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-016-serviceaccount-without-binding.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-020-6-cluster-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-6-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/ns-002-1-place-pod-in-kube-system-dedicated-sa.kube-system", "valid": true, "fileName": "manifests/ns-002-1-place-pod-in-kube-system.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/ns-002-1-place-pod-in-kube-system.kube-system", "valid": true, "fileName": "manifests/ns-002-1-place-pod-in-kube-system.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-005-2-allow-pods-sharing-host-network-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-005-2-allow-pods-sharing-host-network-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-010-7-cluster-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-7-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-22-using-insecure-capability-sys-ptrace-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-22-using-insecure-capability-sys-ptrace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-22-using-insecure-capability-sys-ptrace.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-22-using-insecure-capability-sys-ptrace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/ps-001-no-pod-security-admission-label-configured.ps-001-no-pod-security-admission-label-configured", "valid": true, "fileName": "manifests/ps-001-no-pod-security-admission-label-configured.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/ps-001-no-pod-security-admission-label-configured.ps-001-no-pod-security-admission-label-configured", "valid": true, "fileName": "manifests/ps-001-no-pod-security-admission-label-configured.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/ps-001-no-pod-security-admission-label-configured.ps-001-no-pod-security-admission-label-configured", "valid": true, "fileName": "manifests/ps-001-no-pod-security-admission-label-configured.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/ps-001-no-pod-security-admission-label-configured.ps-001-no-pod-security-admission-label-configured", "valid": true, "fileName": "manifests/ps-001-no-pod-security-admission-label-configured.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/ps-001-no-pod-security-admission-label-configured-filler-dedicated-sa.ps-001-no-pod-security-admission-label-configured", "valid": true, "fileName": "manifests/ps-001-no-pod-security-admission-label-configured.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/ps-001-no-pod-security-admission-label-configured.ps-001-no-pod-security-admission-label-configured", "valid": true, "fileName": "manifests/ps-001-no-pod-security-admission-label-configured.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-020-5-cluster-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-5-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-7-using-insecure-capability-kill-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-7-using-insecure-capability-kill.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-7-using-insecure-capability-kill.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-7-using-insecure-capability-kill.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/sc-002-2-using-latest-image-tag-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/sc-002-2-using-latest-image-tag.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/sc-002-2-using-latest-image-tag.kalm-benchmark", "valid": true, "fileName": "manifests/sc-002-2-using-latest-image-tag.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-006-1-pod-exec.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-006-1-role-exec-into-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-003-9-no-automount-pod-and-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-9-no-automount-pod-and-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-9-no-automount-pod-and-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-9-no-automount-pod-and-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/rel-003-no-priorityclass-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rel-003-no-priorityclass.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/rel-003-no-priorityclass.kalm-benchmark", "valid": true, "fileName": "manifests/rel-003-no-priorityclass.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-002-1-secret-read-get.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-002-1-read-access-to-secrets.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-015-3-cluster-role-poison-dns.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-015-3-cluster-role-core-dns-poisoning.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Role/rbac-002-3-secret-read-watch.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-002-3-read-access-to-secrets.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-016-no-podsecuritycontext-defined-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-016-no-podsecuritycontext-defined.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-016-no-podsecuritycontext-defined.kalm-benchmark", "valid": true, "fileName": "manifests/pod-016-no-podsecuritycontext-defined.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-042-3-volume-with-writeable-hostpath-by-default-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-042-3-volume-with-writeable-hostpath-by-default.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-042-3-volume-with-writeable-hostpath-by-default.kalm-benchmark", "valid": true, "fileName": "manifests/pod-042-3-volume-with-writeable-hostpath-by-default.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-20-using-insecure-capability-sys-module-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-20-using-insecure-capability-sys-module.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-20-using-insecure-capability-sys-module.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-20-using-insecure-capability-sys-module.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-018-3-use-uid-between-1k-10k-on-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-3-use-uid-between-1k-10k-on-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-018-3-use-uid-between-1k-10k-on-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-3-use-uid-between-1k-10k-on-container.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-008-4-allow-root-groups-in-pods-must-higher-gid.kalm-benchmark", "valid": false, "fileName": "manifests/psp-008-4-allow-root-groups-in-pods-must-higher-gid.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-009-allowing-net-raw.kalm-benchmark", "valid": false, "fileName": "manifests/psp-009-allowing-net-raw.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-015-4-cluster-role-poison-dns.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-015-4-cluster-role-core-dns-poisoning.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-019-5-use-gid-set-in-container-takes-precedence-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-5-use-gid-set-in-container-takes-precedence.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-019-5-use-gid-set-in-container-takes-precedence.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-5-use-gid-set-in-container-takes-precedence.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-013-2-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-013-2-role-destructive.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-013-2-not-confining-apparmor.kalm-benchmark", "valid": false, "fileName": "manifests/psp-013-2-not-confining-apparmor.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-008-2-allow-root-groups-in-pods-may-gid-range.kalm-benchmark", "valid": false, "fileName": "manifests/psp-008-2-allow-root-groups-in-pods-may-gid-range.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-036-keep-default-capabilities-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-036-keep-default-capabilities.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-036-keep-default-capabilities.kalm-benchmark", "valid": true, "fileName": "manifests/pod-036-keep-default-capabilities.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-011-1-allowing-read-only-root-filesystem.kalm-benchmark", "valid": false, "fileName": "manifests/psp-011-1-allowing-read-only-root-filesystem.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/rel-001-no-readinessprobe-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rel-001-no-readinessprobe.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/rel-001-no-readinessprobe.kalm-benchmark", "valid": true, "fileName": "manifests/rel-001-no-readinessprobe.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/wl-001-naked-pod-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/wl-001-naked-pod.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Pod/wl-001-naked-pod.kalm-benchmark", "valid": true, "fileName": "manifests/wl-001-naked-pod.yaml", "message": "Passed with a score of 16 points", "score": 16, "scoring": {"passed": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "ServiceAccount/res-006-1-default-ephemeral-storage-limits-from-namespace-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/res-006-1-default-ephemeral-storage-limits-from-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-006-1-default-ephemeral-storage-limits-from-namespace.kalm-benchmark", "valid": true, "fileName": "manifests/res-006-1-default-ephemeral-storage-limits-from-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-003-4-automount-pod-default-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-4-automount-pod-default-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-4-automount-pod-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-4-automount-pod-default-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/sc-001-1-imagepullpolicy-defaults-to-always-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/sc-001-1-imagepullpolicy-defaults-to-always.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/sc-001-1-imagepullpolicy-defaults-to-always.kalm-benchmark", "valid": true, "fileName": "manifests/sc-001-1-imagepullpolicy-defaults-to-always.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-015-2-role-poison-dns.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-015-2-role-core-dns-poisoning.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Role/rbac-020-4-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-4-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-017-4-use-root-user-in-pod-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-4-use-root-user-in-pod.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-4-use-root-user-in-pod.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-4-use-root-user-in-pod.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-2-using-insecure-capability-bpf-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-2-using-insecure-capability-bpf.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-2-using-insecure-capability-bpf.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-2-using-insecure-capability-bpf.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-021-0-using-sysctl-kernel.shm-rmid-forced-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-021-0-using-sysctl-kernel.shm-rmid-forced-c808ea91.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-021-0-using-sysctl-kernel.shm-rmid-forced.kalm-benchmark", "valid": true, "fileName": "manifests/pod-021-0-using-sysctl-kernel.shm-rmid-forced-c808ea91.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-012-6-cluster-role-disclose-info.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-012-6-cluster-role-info-disclosure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/sc-002-1-tag-instead-of-digest-is-fine-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/sc-002-1-tag-instead-of-digest-is-fine.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/sc-002-1-tag-instead-of-digest-is-fine.kalm-benchmark", "valid": true, "fileName": "manifests/sc-002-1-tag-instead-of-digest-is-fine.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-010-5-cluster-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-5-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/sc-001-3-no-proper-imagepullpolicy-set-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/sc-001-3-no-proper-imagepullpolicy-set.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/sc-001-3-no-proper-imagepullpolicy-set.kalm-benchmark", "valid": true, "fileName": "manifests/sc-001-3-no-proper-imagepullpolicy-set.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-024-7-usage-of-bin-busybox-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-7-usage-of-bin-busybox-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-7-usage-of-bin-busybox-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-7-usage-of-bin-busybox-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-005-1-pod-attach.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-005-1-role-attaches-to-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-010-8-cluster-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-8-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-012-4-cluster-role-disclose-info.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-012-4-cluster-role-info-disclosure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-031-1-allowed-privilege-escalation-by-default-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-031-1-allowed-privilege-escalation-by-default.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-031-1-allowed-privilege-escalation-by-default.kalm-benchmark", "valid": true, "fileName": "manifests/pod-031-1-allowed-privilege-escalation-by-default.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-004-1-allow-pods-sharing-hostipc-namespace.kalm-benchmark", "valid": false, "fileName": "manifests/psp-004-1-allow-pods-sharing-hostipc-namespace.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/res-001-1-default-memory-requests-from-namespace-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/res-001-1-default-memory-requests-from-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-001-1-default-memory-requests-from-namespace.kalm-benchmark", "valid": true, "fileName": "manifests/res-001-1-default-memory-requests-from-namespace.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}]}}], [{"object": "ClusterRole/rbac-003-6-cluster-all-ns-verbs.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-003-6-cluster-role-use-verb-wildcard.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-019-2-use-gid-between-1k-10k-on-pod-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-2-use-gid-between-1k-10k-on-pod.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-019-2-use-gid-between-1k-10k-on-pod.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-2-use-gid-between-1k-10k-on-pod.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-017-3-runasnonroot-is-optional-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-3-runasnonroot-is-optional.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-3-runasnonroot-is-optional.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-3-runasnonroot-is-optional.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "ServiceAccount/pod-008-2-pod-has-hostpid-set-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-008-2-pod-has-hostpid-set.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-008-2-pod-has-hostpid-set.kalm-benchmark", "valid": true, "fileName": "manifests/pod-008-2-pod-has-hostpid-set.yaml", "message": "Passed with a score of 3 points", "score": 3, "scoring": {"critical": [{"id": "HostPID", "selector": ".spec .hostPID == true", "reason": "Sharing the host's PID namespace allows visibility of processes on the host, potentially leaking information such as environment variables and configuration", "points": -9}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-010-2-has-hostnetwork-set-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-010-2-has-hostnetwork-set.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-010-2-has-hostnetwork-set.kalm-benchmark", "valid": true, "fileName": "manifests/pod-010-2-has-hostnetwork-set.yaml", "message": "Passed with a score of 3 points", "score": 3, "scoring": {"critical": [{"id": "HostNetwork", "selector": ".spec .hostNetwork == true", "reason": "Sharing the host's network namespace permits processes in the pod to communicate with processes bound to the host's loopback adapter", "points": -9}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-008-5-cluster-pod-forward.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-008-5-cluster-role-port-forward-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/sc-002-3-no-explicit-tag-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/sc-002-3-no-explicit-tag.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/sc-002-3-no-explicit-tag.kalm-benchmark", "valid": true, "fileName": "manifests/sc-002-3-no-explicit-tag.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-017-8-set-runasnonroot-correctly-on-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-8-set-runasnonroot-correctly-on-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-8-set-runasnonroot-correctly-on-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-8-set-runasnonroot-correctly-on-container.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "Role/rbac-020-2-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-2-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-012-5-cluster-role-disclose-info.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-012-5-cluster-role-info-disclosure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-003-7-no-automount-pod-default-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-7-no-automount-pod-default-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-7-no-automount-pod-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-7-no-automount-pod-default-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-002-4-secret-read-get.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-002-4-read-access-to-secrets.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Namespace/res-008-2-no-default-memory-limits-for-namespace.res-008-2-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-2-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-008-2-no-default-memory-limits-for-namespace.res-008-2-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-2-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-008-2-no-default-memory-limits-for-namespace.res-008-2-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-2-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-008-2-no-default-memory-limits-for-namespace.res-008-2-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-2-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-008-2-no-default-memory-limits-for-namespace-filler-dedicated-sa.res-008-2-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-2-no-default-memory-limits-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-008-2-no-default-memory-limits-for-namespace.res-008-2-no-default-memory-limits-for-namespace", "valid": true, "fileName": "manifests/res-008-2-no-default-memory-limits-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-009-2-cluster-role-bind-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-009-2-cluster-role-impersonation.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-024-1-usage-of-sbin-sh-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-1-usage-of-sbin-sh-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-1-usage-of-sbin-sh-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-1-usage-of-sbin-sh-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-003-5-all-ns-verbs.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-003-5-role-use-verb-wildcard.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-007-2-allow-root-users-in-pods-uid-range.kalm-benchmark", "valid": false, "fileName": "manifests/psp-007-2-allow-root-users-in-pods-uid-range.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-034-3-using-dangerous-capability-net-admin-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-034-3-using-dangerous-capability-net-admin.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-034-3-using-dangerous-capability-net-admin.kalm-benchmark", "valid": true, "fileName": "manifests/pod-034-3-using-dangerous-capability-net-admin.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-013-1-not-configuring-apparmor-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-013-1-not-configuring-apparmor-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-019-3-use-gid-between-1k-10k-on-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-3-use-gid-between-1k-10k-on-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-019-3-use-gid-between-1k-10k-on-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-3-use-gid-between-1k-10k-on-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-003-3-default-pod-no-automount-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-3-default-pod-no-automount-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-3-default-pod-no-automount-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-3-default-pod-no-automount-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-003-8-no-automount-pod-automount-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-8-no-automount-pod-automount-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-8-no-automount-pod-automount-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-8-no-automount-pod-automount-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-5-using-insecure-capability-fowner-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-5-using-insecure-capability-fowner.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-5-using-insecure-capability-fowner.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-5-using-insecure-capability-fowner.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-043-1-mount-azure-cloud-credentials-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-043-1-mount-azure-cloud-credentials.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-043-1-mount-azure-cloud-credentials.kalm-benchmark", "valid": true, "fileName": "manifests/pod-043-1-mount-azure-cloud-credentials.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/res-004-1-default-cpu-limits-from-namespace-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/res-004-1-default-cpu-limits-from-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-004-1-default-cpu-limits-from-namespace.kalm-benchmark", "valid": true, "fileName": "manifests/res-004-1-default-cpu-limits-from-namespace.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}]}}], [{"object": "ServiceAccount/pod-014-no-apparmor-profile-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-014-no-apparmor-profile.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-014-no-apparmor-profile.kalm-benchmark", "valid": true, "fileName": "manifests/pod-014-no-apparmor-profile.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-044-2-mounting-docker-directory-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-044-2-mounting-docker-directory.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-044-2-mounting-docker-directory.kalm-benchmark", "valid": true, "fileName": "manifests/pod-044-2-mounting-docker-directory.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-006-2-cluster-pod-exec.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-006-2-cluster-role-exec-into-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRoleBinding/rbac-001-2-use-cluster-admin-role-cluster-wide-rb-cluster-admin.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-001-2-use-cluster-admin-role-cluster-wide.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/res-006-2-no-ephemeral-storage-limits-dedicated-sa.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-006-2-no-ephemeral-storage-limits.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-006-2-no-ephemeral-storage-limits.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-006-2-no-ephemeral-storage-limits.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-024-6-usage-of-bin-csh-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-6-usage-of-bin-csh-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-6-usage-of-bin-csh-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-6-usage-of-bin-csh-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/np-002-1-only-ingress-is-blocked.np-002-1-only-ingress-is-blocked", "valid": true, "fileName": "manifests/np-002-1-only-ingress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/np-002-1-only-ingress-is-blocked.np-002-1-only-ingress-is-blocked", "valid": true, "fileName": "manifests/np-002-1-only-ingress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/np-002-1-only-ingress-is-blocked.np-002-1-only-ingress-is-blocked", "valid": true, "fileName": "manifests/np-002-1-only-ingress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/np-002-1-only-ingress-is-blocked.np-002-1-only-ingress-is-blocked", "valid": true, "fileName": "manifests/np-002-1-only-ingress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/np-002-1-only-ingress-is-blocked-filler-dedicated-sa.np-002-1-only-ingress-is-blocked", "valid": true, "fileName": "manifests/np-002-1-only-ingress-is-blocked.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/np-002-1-only-ingress-is-blocked.np-002-1-only-ingress-is-blocked", "valid": true, "fileName": "manifests/np-002-1-only-ingress-is-blocked.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-002-2-allow-privilege-escalation-in-containers-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-002-2-allow-privilege-escalation-in-containers-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Role/rbac-012-2-role-disclose-info.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-012-2-role-info-disclosure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-012-use-hostaliases-to-modify-pods--etc-hosts-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-012-use-hostaliases-to-modify-pods--etc-hosts.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-012-use-hostaliases-to-modify-pods--etc-hosts.kalm-benchmark", "valid": true, "fileName": "manifests/pod-012-use-hostaliases-to-modify-pods--etc-hosts.yaml", "message": "Passed with a score of 9 points", "score": 9, "scoring": {"critical": [{"id": "HostAliases", "selector": ".spec .hostAliases", "reason": "Managing /etc/hosts aliases can prevent the container from modifying the file after a pod's containers have already been started. DNS should be managed by the orchestrator", "points": -3}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-007-1-allow-root-users-in-pods.kalm-benchmark", "valid": false, "fileName": "manifests/psp-007-1-allow-root-users-in-pods.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/res-005-2-no-ephemeral-storage-requests-dedicated-sa.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-005-2-no-ephemeral-storage-requests.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-005-2-no-ephemeral-storage-requests.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-005-2-no-ephemeral-storage-requests.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRoleBinding/rbac-007-2-cluster-role-binds-default-serviceaccount-rb-rbac-007-2-cluster-role-bind-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-007-2-cluster-role-binds-default-serviceaccount.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ClusterRole/rbac-007-2-cluster-role-bind-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-007-2-cluster-role-binds-default-serviceaccount.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Namespace/np-005-network-policy-refers-no-valid-workload.np-005-network-policy-refers-no-valid-workload", "valid": true, "fileName": "manifests/np-005-network-policy-refers-no-valid-workload.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/np-005-network-policy-refers-no-valid-workload.np-005-network-policy-refers-no-valid-workload", "valid": true, "fileName": "manifests/np-005-network-policy-refers-no-valid-workload.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/np-005-network-policy-refers-no-valid-workload.np-005-network-policy-refers-no-valid-workload", "valid": true, "fileName": "manifests/np-005-network-policy-refers-no-valid-workload.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/np-005-network-policy-refers-no-valid-workload.np-005-network-policy-refers-no-valid-workload", "valid": true, "fileName": "manifests/np-005-network-policy-refers-no-valid-workload.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/np-005-network-policy-refers-no-valid-workload-filler-dedicated-sa.np-005-network-policy-refers-no-valid-workload", "valid": true, "fileName": "manifests/np-005-network-policy-refers-no-valid-workload.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/np-005-network-policy-refers-no-valid-workload.np-005-network-policy-refers-no-valid-workload", "valid": true, "fileName": "manifests/np-005-network-policy-refers-no-valid-workload.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-8-using-insecure-capability-mac-override-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-8-using-insecure-capability-mac-override.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-8-using-insecure-capability-mac-override.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-8-using-insecure-capability-mac-override.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-022-1-linux-is-not-hardened-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-022-1-linux-is-not-hardened.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-022-1-linux-is-not-hardened.kalm-benchmark", "valid": true, "fileName": "manifests/pod-022-1-linux-is-not-hardened.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-031-2-allowed-privilege-escalation-explicitly-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-031-2-allowed-privilege-escalation-explicitly.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-031-2-allowed-privilege-escalation-explicitly.kalm-benchmark", "valid": true, "fileName": "manifests/pod-031-2-allowed-privilege-escalation-explicitly.yaml", "message": "Passed with a score of 5 points", "score": 5, "scoring": {"critical": [{"id": "AllowPrivilegeEscalation", "selector": "containers[] .securityContext .allowPrivilegeEscalation == true", "reason": "", "points": -7}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/deprecated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-013-use-serviceaccount-field.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-013-use-serviceaccount-field.kalm-benchmark", "valid": true, "fileName": "manifests/pod-013-use-serviceaccount-field.yaml", "message": "Passed with a score of 9 points", "score": 9, "scoring": {"passed": [{"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/ns-002-2-place-pod-in-kube-public-dedicated-sa.kube-public", "valid": true, "fileName": "manifests/ns-002-2-place-pod-in-kube-public.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/ns-002-2-place-pod-in-kube-public.kube-public", "valid": true, "fileName": "manifests/ns-002-2-place-pod-in-kube-public.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-3-using-insecure-capability-chown-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-3-using-insecure-capability-chown.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-3-using-insecure-capability-chown.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-3-using-insecure-capability-chown.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-010-1-use-no-hostnetwork-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-010-1-use-no-hostnetwork.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-010-1-use-no-hostnetwork.kalm-benchmark", "valid": true, "fileName": "manifests/pod-010-1-use-no-hostnetwork.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-004-2-cluster-pod-creator.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-004-2-cluster-role-creates-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-0-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-0-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-1-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-1-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-2-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-2-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-3-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-3-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-4-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-4-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-5-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-5-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-6-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-6-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-7-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-7-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-8-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-8-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "RoleBinding/rbac-017-too-many-roles-per-subject-rb-rbac-017-role-9-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Role/rbac-017-role-9-too-much.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-017-too-many-roles-per-subject.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-024-2-usage-of-bin-ksh-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-2-usage-of-bin-ksh-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-2-usage-of-bin-ksh-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-2-usage-of-bin-ksh-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-017-2-use-runasnonroot-flag-on-pod-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-2-use-runasnonroot-flag-on-pod.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-2-use-runasnonroot-flag-on-pod.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-2-use-runasnonroot-flag-on-pod.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "ClusterRole/rbac-005-2-cluster-pod-attach.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-005-2-cluster-role-attaches-to-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Role/rbac-008-1-pod-forward.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-008-1-role-port-forward-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Role/rbac-002-2-secret-read-list.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-002-2-read-access-to-secrets.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-014-3-cluster--destroy-events.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-014-3-cluster-role-event-deletion.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-004-2-allow-pods-sharing-hostipc-namespace-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-004-2-allow-pods-sharing-hostipc-namespace-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Namespace/np-001-namespace-without-network-policy.np-001-namespace-without-network-policy", "valid": true, "fileName": "manifests/np-001-namespace-without-network-policy.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/np-001-namespace-without-network-policy.np-001-namespace-without-network-policy", "valid": true, "fileName": "manifests/np-001-namespace-without-network-policy.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/np-001-namespace-without-network-policy.np-001-namespace-without-network-policy", "valid": true, "fileName": "manifests/np-001-namespace-without-network-policy.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Namespace/np-004-network-policy-allows-access-to-kubelet.np-004-network-policy-allows-access-to-kubelet", "valid": true, "fileName": "manifests/np-004-network-policy-allows-access-to-kubelet.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/np-004-network-policy-allows-access-to-kubelet.np-004-network-policy-allows-access-to-kubelet", "valid": true, "fileName": "manifests/np-004-network-policy-allows-access-to-kubelet.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/np-004-network-policy-allows-access-to-kubelet.np-004-network-policy-allows-access-to-kubelet", "valid": true, "fileName": "manifests/np-004-network-policy-allows-access-to-kubelet.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/np-004-network-policy-allows-access-to-kubelet.np-004-network-policy-allows-access-to-kubelet", "valid": true, "fileName": "manifests/np-004-network-policy-allows-access-to-kubelet.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/np-004-network-policy-allows-access-to-kubelet.np-004-network-policy-allows-access-to-kubelet", "valid": true, "fileName": "manifests/np-004-network-policy-allows-access-to-kubelet.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/np-004-network-policy-allows-access-to-kubelet-filler-dedicated-sa.np-004-network-policy-allows-access-to-kubelet", "valid": true, "fileName": "manifests/np-004-network-policy-allows-access-to-kubelet.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/np-004-network-policy-allows-access-to-kubelet.np-004-network-policy-allows-access-to-kubelet", "valid": true, "fileName": "manifests/np-004-network-policy-allows-access-to-kubelet.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-009-1-use-no-hostipc-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-009-1-use-no-hostipc.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-009-1-use-no-hostipc.kalm-benchmark", "valid": true, "fileName": "manifests/pod-009-1-use-no-hostipc.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-009-1-role-bind-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-009-1-role-impersonation.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-034-2-using-dangerous-capability-sys-admin-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-034-2-using-dangerous-capability-sys-admin.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-034-2-using-dangerous-capability-sys-admin.kalm-benchmark", "valid": true, "fileName": "manifests/pod-034-2-using-dangerous-capability-sys-admin.yaml", "message": "Failed with a score of -18 points", "score": -18, "scoring": {"critical": [{"id": "CapSysAdmin", "selector": "containers[] .securityContext .capabilities .add == SYS_ADMIN", "reason": "CAP_SYS_ADMIN is the most privileged capability and should always be avoided", "points": -30}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-008-3-allow-root-groups-in-pods-may-higher-gid.kalm-benchmark", "valid": false, "fileName": "manifests/psp-008-3-allow-root-groups-in-pods-may-higher-gid.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Role/rbac-012-3-role-disclose-info.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-012-3-role-info-disclosure.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/res-003-2-no-cpu-requests-dedicated-sa.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-003-2-no-cpu-requests.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-003-2-no-cpu-requests.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-003-2-no-cpu-requests.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}]}}], [{"object": "Role/rbac-013-1-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-013-1-role-destructive.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-1-using-insecure-capability-audit-write-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-1-using-insecure-capability-audit-write.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-1-using-insecure-capability-audit-write.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-1-using-insecure-capability-audit-write.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-014-2--destroy-events.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-014-2-role-event-deletion.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Namespace/ps-001-1-podsecurity-level-should-be-specified.ps-001-1-podsecurity-level-should-be-specified", "valid": true, "fileName": "manifests/ps-001-1-podsecurity-level-should-be-specified.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/ps-001-1-podsecurity-level-should-be-specified.ps-001-1-podsecurity-level-should-be-specified", "valid": true, "fileName": "manifests/ps-001-1-podsecurity-level-should-be-specified.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/ps-001-1-podsecurity-level-should-be-specified.ps-001-1-podsecurity-level-should-be-specified", "valid": true, "fileName": "manifests/ps-001-1-podsecurity-level-should-be-specified.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/ps-001-1-podsecurity-level-should-be-specified.ps-001-1-podsecurity-level-should-be-specified", "valid": true, "fileName": "manifests/ps-001-1-podsecurity-level-should-be-specified.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/ps-001-1-podsecurity-level-should-be-specified-filler-dedicated-sa.ps-001-1-podsecurity-level-should-be-specified", "valid": true, "fileName": "manifests/ps-001-1-podsecurity-level-should-be-specified.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/ps-001-1-podsecurity-level-should-be-specified.ps-001-1-podsecurity-level-should-be-specified", "valid": true, "fileName": "manifests/ps-001-1-podsecurity-level-should-be-specified.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ConfigMap/cm-001-sensitive-key-referenced-in-configmap.kalm-benchmark", "valid": true, "fileName": "manifests/cm-001-sensitive-key-referenced-in-configmap.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-11-using-insecure-capability-net-bind-service-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-11-using-insecure-capability-net-bind-service.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-11-using-insecure-capability-net-bind-service.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-11-using-insecure-capability-net-bind-service.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-003-6-automount-pod-no-automount-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-6-automount-pod-no-automount-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-6-automount-pod-no-automount-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-6-automount-pod-no-automount-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-018-2-use-uid-between-1k-10k-on-pod-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-2-use-uid-between-1k-10k-on-pod.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-018-2-use-uid-between-1k-10k-on-pod.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-2-use-uid-between-1k-10k-on-pod.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "Namespace/res-007-1-no-default-cpu-request-for-namespace.res-007-1-no-default-cpu-request-for-namespace", "valid": true, "fileName": "manifests/res-007-1-no-default-cpu-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-007-1-no-default-cpu-request-for-namespace.res-007-1-no-default-cpu-request-for-namespace", "valid": true, "fileName": "manifests/res-007-1-no-default-cpu-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-007-1-no-default-cpu-request-for-namespace.res-007-1-no-default-cpu-request-for-namespace", "valid": true, "fileName": "manifests/res-007-1-no-default-cpu-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-007-1-no-default-cpu-request-for-namespace.res-007-1-no-default-cpu-request-for-namespace", "valid": true, "fileName": "manifests/res-007-1-no-default-cpu-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-007-1-no-default-cpu-request-for-namespace-filler-dedicated-sa.res-007-1-no-default-cpu-request-for-namespace", "valid": true, "fileName": "manifests/res-007-1-no-default-cpu-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-007-1-no-default-cpu-request-for-namespace.res-007-1-no-default-cpu-request-for-namespace", "valid": true, "fileName": "manifests/res-007-1-no-default-cpu-request-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-002-1-allow-privilege-escalation-in-containers.kalm-benchmark", "valid": false, "fileName": "manifests/psp-002-1-allow-privilege-escalation-in-containers.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-10-using-insecure-capability-mknod-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-10-using-insecure-capability-mknod.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-10-using-insecure-capability-mknod.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-10-using-insecure-capability-mknod.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-011-2-allowing-read-only-root-filesystem.kalm-benchmark", "valid": false, "fileName": "manifests/psp-011-2-allowing-read-only-root-filesystem.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Role/rbac-003-1-all-resource-reader.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-003-1-role-use-resource-wildcard.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PriorityClass/default-priority.default", "valid": true, "fileName": "manifests/_default-priority-c8fbe908.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-032-1-non-privileged-container-by-default-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-032-1-non-privileged-container-by-default.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-032-1-non-privileged-container-by-default.kalm-benchmark", "valid": true, "fileName": "manifests/pod-032-1-non-privileged-container-by-default.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/rel-004-1-no-node-selection-specified-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rel-004-1-no-node-selection-specified.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/rel-004-1-no-node-selection-specified.kalm-benchmark", "valid": true, "fileName": "manifests/rel-004-1-no-node-selection-specified.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-017-7-use-root-user-on-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-7-use-root-user-on-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-7-use-root-user-on-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-7-use-root-user-on-container.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "Role/rbac-010-2-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-2-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-21-using-insecure-capability-sys-rawio-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-21-using-insecure-capability-sys-rawio.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-21-using-insecure-capability-sys-rawio.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-21-using-insecure-capability-sys-rawio.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-4-using-insecure-capability-dac-overrides-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-4-using-insecure-capability-dac-overrides.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-4-using-insecure-capability-dac-overrides.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-4-using-insecure-capability-dac-overrides.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-008-3-pod-forward.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-008-3-role-port-forward-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-024-5-usage-of-usr-bin-scsh-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-5-usage-of-usr-bin-scsh-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-5-usage-of-usr-bin-scsh-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-5-usage-of-usr-bin-scsh-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Deployment/pod-002-2-no-sa-specified.kalm-benchmark", "valid": true, "fileName": "manifests/pod-002-2-no-sa-specified.yaml", "message": "Passed with a score of 9 points", "score": 9, "scoring": {"passed": [{"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/res-001-2-no-memory-requests-dedicated-sa.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-001-2-no-memory-requests.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-001-2-no-memory-requests.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-001-2-no-memory-requests.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}]}}], [{"object": "ServiceAccount/pod-022-2-one-approach-to-hardening-linux-is-enough-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-022-2-one-approach-to-hardening-linux-is-enough.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-022-2-one-approach-to-hardening-linux-is-enough.kalm-benchmark", "valid": true, "fileName": "manifests/pod-022-2-one-approach-to-hardening-linux-is-enough.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-020-8-cluster-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-8-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-019-1-default-to-root-group-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-1-default-to-root-group.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-019-1-default-to-root-group.kalm-benchmark", "valid": true, "fileName": "manifests/pod-019-1-default-to-root-group.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-014-4-cluster--destroy-events.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-014-4-cluster-role-event-deletion.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-020-7-cluster-role-escalate-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-020-7-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-018-4-use-uid-set-in-container-takes-precedence-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-4-use-uid-set-in-container-takes-precedence.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-018-4-use-uid-set-in-container-takes-precedence.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-4-use-uid-set-in-container-takes-precedence.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-003-1-allow-pods-sharing-hostpid.kalm-benchmark", "valid": false, "fileName": "manifests/psp-003-1-allow-pods-sharing-hostpid.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-15-using-insecure-capability-setgid-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-15-using-insecure-capability-setgid.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-15-using-insecure-capability-setgid.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-15-using-insecure-capability-setgid.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-004-1-pod-creator.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-004-1-role-creates-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-008-1-allow-root-groups-in-pods-must-gid-range.kalm-benchmark", "valid": false, "fileName": "manifests/psp-008-1-allow-root-groups-in-pods-must-gid-range.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Namespace/res-008-1-no-default-memory-request-for-namespace.res-008-1-no-default-memory-request-for-namespace", "valid": true, "fileName": "manifests/res-008-1-no-default-memory-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-008-1-no-default-memory-request-for-namespace.res-008-1-no-default-memory-request-for-namespace", "valid": true, "fileName": "manifests/res-008-1-no-default-memory-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-008-1-no-default-memory-request-for-namespace.res-008-1-no-default-memory-request-for-namespace", "valid": true, "fileName": "manifests/res-008-1-no-default-memory-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-008-1-no-default-memory-request-for-namespace.res-008-1-no-default-memory-request-for-namespace", "valid": true, "fileName": "manifests/res-008-1-no-default-memory-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-008-1-no-default-memory-request-for-namespace-filler-dedicated-sa.res-008-1-no-default-memory-request-for-namespace", "valid": true, "fileName": "manifests/res-008-1-no-default-memory-request-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-008-1-no-default-memory-request-for-namespace.res-008-1-no-default-memory-request-for-namespace", "valid": true, "fileName": "manifests/res-008-1-no-default-memory-request-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-013-3-not-restricting-allowed-apparmor-profiles.kalm-benchmark", "valid": false, "fileName": "manifests/psp-013-3-not-restricting-allowed-apparmor-profiles.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-008-6-cluster-pod-forward.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-008-6-cluster-role-port-forward-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "RoleBinding/rbac-001-1-use-cluster-admin-role-rb-cluster-admin.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-001-1-use-cluster-admin-role.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-035-12-using-insecure-capability-net-raw-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-12-using-insecure-capability-net-raw.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-12-using-insecure-capability-net-raw.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-12-using-insecure-capability-net-raw.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-010-4-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-4-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/rel-004-2-only-nodeaffinity-is-enough-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rel-004-2-only-nodeaffinity-is-enough.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/rel-004-2-only-nodeaffinity-is-enough.kalm-benchmark", "valid": true, "fileName": "manifests/rel-004-2-only-nodeaffinity-is-enough.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-009-2-has-hostipc-set-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-009-2-has-hostipc-set.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-009-2-has-hostipc-set.kalm-benchmark", "valid": true, "fileName": "manifests/pod-009-2-has-hostipc-set.yaml", "message": "Passed with a score of 3 points", "score": 3, "scoring": {"critical": [{"id": "HostIPC", "selector": ".spec .hostIPC == true", "reason": "Sharing the host's IPC namespace allows container processes to communicate with processes on the host", "points": -9}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Deployment/pod-002-1-explicit-default-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-002-1-explicit-default-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-044-1-mounting-docker-socket-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-044-1-mounting-docker-socket.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-044-1-mounting-docker-socket.kalm-benchmark", "valid": true, "fileName": "manifests/pod-044-1-mounting-docker-socket.yaml", "message": "Passed with a score of 3 points", "score": 3, "scoring": {"critical": [{"id": "DockerSock", "selector": "volumes[] .hostPath .path == /var/run/docker.sock", "reason": "Mounting the docker.socket leaks information about other containers and can allow container breakout", "points": -9}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-014-3-not-restricting-allowed-seccomp-profiles.kalm-benchmark", "valid": false, "fileName": "manifests/psp-014-3-not-restricting-allowed-seccomp-profiles.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/sc-001-2-no-proper-imagepullpolicy-set-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/sc-001-2-no-proper-imagepullpolicy-set.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/sc-001-2-no-proper-imagepullpolicy-set.kalm-benchmark", "valid": true, "fileName": "manifests/sc-001-2-no-proper-imagepullpolicy-set.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-003-5-automount-pod-and-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-5-automount-pod-and-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-5-automount-pod-and-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-5-automount-pod-and-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/rel-004-3-only-nodeselector-is-enough-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/rel-004-3-only-nodeselector-is-enough.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/rel-004-3-only-nodeselector-is-enough.kalm-benchmark", "valid": true, "fileName": "manifests/rel-004-3-only-nodeselector-is-enough.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-024-3-usage-of-bin-tcsh-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-3-usage-of-bin-tcsh-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-3-usage-of-bin-tcsh-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-3-usage-of-bin-tcsh-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ClusterRole/rbac-002-5-secret-read-list.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-002-5-read-access-to-secrets.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-032-2-privileged-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-032-2-privileged-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-032-2-privileged-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-032-2-privileged-container.yaml", "message": "Failed with a score of -18 points", "score": -18, "scoring": {"critical": [{"id": "Privileged", "selector": "containers[] .securityContext .privileged == true", "reason": "Privileged containers can allow almost completely unrestricted host access", "points": -30}], "passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-021-2-using-sysctl-net.ipv4.tcp-keepalive-probes-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-021-2-using-sysctl-net.ipv4.tcp-keepalive-probes-c83975aa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-021-2-using-sysctl-net.ipv4.tcp-keepalive-probes.kalm-benchmark", "valid": true, "fileName": "manifests/pod-021-2-using-sysctl-net.ipv4.tcp-keepalive-probes-c83975aa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace", "valid": true, "fileName": "manifests/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace", "valid": true, "fileName": "manifests/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace", "valid": true, "fileName": "manifests/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace", "valid": true, "fileName": "manifests/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace-filler-dedicated-sa.res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace", "valid": true, "fileName": "manifests/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace", "valid": true, "fileName": "manifests/res-009-2-no-hard-quotas-defined-in-resourcequota-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-13-using-insecure-capability-perfmon-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-13-using-insecure-capability-perfmon.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-13-using-insecure-capability-perfmon.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-13-using-insecure-capability-perfmon.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/kalm-benchmark-unrestricted-ns.default", "valid": true, "fileName": "manifests/_kalm-benchmark-unrestricted-ns-c849031e.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/kalm-benchmark-unrestricted-ns.default", "valid": true, "fileName": "manifests/_kalm-benchmark-unrestricted-ns-c849031e.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-003-2-cluster-all-resource-reader.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-003-2-cluster-role-use-resource-wildcard.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-013-3-cluster-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-013-3-cluster-role-destructive.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-006-3-disallow-all-host-paths-properly.kalm-benchmark", "valid": false, "fileName": "manifests/psp-006-3-disallow-all-host-paths-properly.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/ns-001-use-default-namespace-dedicated-sa.default", "valid": true, "fileName": "manifests/ns-001-use-default-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/ns-001-use-default-namespace.default", "valid": true, "fileName": "manifests/ns-001-use-default-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/res-007-0-no-limitrange-object-for-namespace.res-007-0-no-limitrange-object-for-namespace", "valid": true, "fileName": "manifests/res-007-0-no-limitrange-object-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/res-007-0-no-limitrange-object-for-namespace.res-007-0-no-limitrange-object-for-namespace", "valid": true, "fileName": "manifests/res-007-0-no-limitrange-object-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/res-007-0-no-limitrange-object-for-namespace.res-007-0-no-limitrange-object-for-namespace", "valid": true, "fileName": "manifests/res-007-0-no-limitrange-object-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/res-007-0-no-limitrange-object-for-namespace-filler-dedicated-sa.res-007-0-no-limitrange-object-for-namespace", "valid": true, "fileName": "manifests/res-007-0-no-limitrange-object-for-namespace.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-007-0-no-limitrange-object-for-namespace.res-007-0-no-limitrange-object-for-namespace", "valid": true, "fileName": "manifests/res-007-0-no-limitrange-object-for-namespace.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-014-1--destroy-events.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-014-1-role-event-deletion.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-018-5-use-uid-set-in-container-takes-precedence-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-5-use-uid-set-in-container-takes-precedence.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-018-5-use-uid-set-in-container-takes-precedence.kalm-benchmark", "valid": true, "fileName": "manifests/pod-018-5-use-uid-set-in-container-takes-precedence.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "ClusterRole/rbac-008-4-cluster-pod-forward.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-008-4-cluster-role-port-forward-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "Namespace/np-003-network-policy-allows-access-to-cloud-metadata-api.np-003-network-policy-allows-access-to-cloud-metadata-api", "valid": true, "fileName": "manifests/np-003-network-policy-allows-access-to-cloud-metadata-api.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/np-003-network-policy-allows-access-to-cloud-metadata-api.np-003-network-policy-allows-access-to-cloud-metadata-api", "valid": true, "fileName": "manifests/np-003-network-policy-allows-access-to-cloud-metadata-api.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/np-003-network-policy-allows-access-to-cloud-metadata-api.np-003-network-policy-allows-access-to-cloud-metadata-api", "valid": true, "fileName": "manifests/np-003-network-policy-allows-access-to-cloud-metadata-api.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/np-003-network-policy-allows-access-to-cloud-metadata-api.np-003-network-policy-allows-access-to-cloud-metadata-api", "valid": true, "fileName": "manifests/np-003-network-policy-allows-access-to-cloud-metadata-api.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/np-003-network-policy-allows-access-to-cloud-metadata-api.np-003-network-policy-allows-access-to-cloud-metadata-api", "valid": true, "fileName": "manifests/np-003-network-policy-allows-access-to-cloud-metadata-api.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ServiceAccount/np-003-network-policy-allows-access-to-cloud-metadata-api-filler-dedicated-sa.np-003-network-policy-allows-access-to-cloud-metadata-api", "valid": true, "fileName": "manifests/np-003-network-policy-allows-access-to-cloud-metadata-api.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/np-003-network-policy-allows-access-to-cloud-metadata-api.np-003-network-policy-allows-access-to-cloud-metadata-api", "valid": true, "fileName": "manifests/np-003-network-policy-allows-access-to-cloud-metadata-api.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/res-002-2-no-memory-limits-dedicated-sa.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-002-2-no-memory-limits.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-002-2-no-memory-limits.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-002-2-no-memory-limits.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}]}}], [{"object": "ServiceAccount/pod-011-uses-hostport-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-011-uses-hostport.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-011-uses-hostport.kalm-benchmark", "valid": true, "fileName": "manifests/pod-011-uses-hostport.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-033-2-root-fs-is-explicitly-writeable-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-033-2-root-fs-is-explicitly-writeable.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-033-2-root-fs-is-explicitly-writeable.kalm-benchmark", "valid": true, "fileName": "manifests/pod-033-2-root-fs-is-explicitly-writeable.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}]}}], [{"object": "ServiceAccount/pod-045-containing-cve-2021-25741-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-045-containing-cve-2021-25741.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-045-containing-cve-2021-25741.kalm-benchmark", "valid": true, "fileName": "manifests/pod-045-containing-cve-2021-25741.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-022-3-one-approach-to-hardening-linux-is-enough-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-022-3-one-approach-to-hardening-linux-is-enough.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-022-3-one-approach-to-hardening-linux-is-enough.kalm-benchmark", "valid": true, "fileName": "manifests/pod-022-3-one-approach-to-hardening-linux-is-enough.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-025-sensitive-key-referenced-in-environment-variable-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-025-sensitive-key-referenced-in-environment-variable.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-025-sensitive-key-referenced-in-environment-variable.kalm-benchmark", "valid": true, "fileName": "manifests/pod-025-sensitive-key-referenced-in-environment-variable.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-003-3-all-ns-verbs.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-003-3-role-use-verb-wildcard.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-006-2-allow-all-host-paths-naive-specification.kalm-benchmark", "valid": false, "fileName": "manifests/psp-006-2-allow-all-host-paths-naive-specification.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-003-1-default-pod-and-sa-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-1-default-pod-and-sa.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-003-1-default-pod-and-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-003-1-default-pod-and-sa.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Role/rbac-015-1-role-poison-dns.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-015-1-role-core-dns-poisoning.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ClusterRole/rbac-010-6-cluster-role-destroy-resources.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-010-6-cluster-role-manages-rbac.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "PodSecurityPolicy/psp-014-2-not-confining-seccomp.kalm-benchmark", "valid": false, "fileName": "manifests/psp-014-2-not-confining-seccomp.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "Role/rbac-008-2-pod-forward.kalm-benchmark", "valid": true, "fileName": "manifests/rbac-008-2-role-port-forward-pods.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-042-2-volume-with-writeable-hostpath-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-042-2-volume-with-writeable-hostpath.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-042-2-volume-with-writeable-hostpath.kalm-benchmark", "valid": true, "fileName": "manifests/pod-042-2-volume-with-writeable-hostpath.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-006-1-allow-all-host-paths-by-default.kalm-benchmark", "valid": false, "fileName": "manifests/psp-006-1-allow-all-host-paths-by-default.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/pod-023-no-seccomp-profile-defined-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-023-no-seccomp-profile-defined.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-023-no-seccomp-profile-defined.kalm-benchmark", "valid": true, "fileName": "manifests/pod-023-no-seccomp-profile-defined.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-18-using-insecure-capability-sys-boot-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-18-using-insecure-capability-sys-boot.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-18-using-insecure-capability-sys-boot.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-18-using-insecure-capability-sys-boot.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-033-1-root-fs-is-writeable-by-default-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-033-1-root-fs-is-writeable-by-default.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-033-1-root-fs-is-writeable-by-default.kalm-benchmark", "valid": true, "fileName": "manifests/pod-033-1-root-fs-is-writeable-by-default.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}]}}], [{"object": "ServiceAccount/pod-030-no-securitycontext-defined-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-030-no-securitycontext-defined.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-030-no-securitycontext-defined.kalm-benchmark", "valid": true, "fileName": "manifests/pod-030-no-securitycontext-defined.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-035-9-using-insecure-capability-mac-admin-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-9-using-insecure-capability-mac-admin.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-035-9-using-insecure-capability-mac-admin.kalm-benchmark", "valid": true, "fileName": "manifests/pod-035-9-using-insecure-capability-mac-admin.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "ServiceAccount/pod-017-1-default-to-root-user-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-1-default-to-root-user.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-017-1-default-to-root-user.kalm-benchmark", "valid": true, "fileName": "manifests/pod-017-1-default-to-root-user.yaml", "message": "Passed with a score of 10 points", "score": 10, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}]}}], [{"object": "PodSecurityPolicy/psp-005-1-allow-pods-sharing-host-network.kalm-benchmark", "valid": false, "fileName": "manifests/psp-005-1-allow-pods-sharing-host-network.yaml", "message": "could not find schema for PodSecurityPolicy", "score": 0, "scoring": {}}], [{"object": "ServiceAccount/res-004-2-no-cpu-limits-dedicated-sa.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-004-2-no-cpu-limits.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/res-004-2-no-cpu-limits.kalm-benchmark-unrestricted-ns", "valid": true, "fileName": "manifests/res-004-2-no-cpu-limits.yaml", "message": "Passed with a score of 11 points", "score": 11, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}]}}], [{"object": "ServiceAccount/pod-024-4-usage-of-bin-zsh-in-container-dedicated-sa.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-4-usage-of-bin-zsh-in-container.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "Deployment/pod-024-4-usage-of-bin-zsh-in-container.kalm-benchmark", "valid": true, "fileName": "manifests/pod-024-4-usage-of-bin-zsh-in-container.yaml", "message": "Passed with a score of 12 points", "score": 12, "scoring": {"passed": [{"id": "ServiceAccountName", "selector": ".spec .serviceAccountName", "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege", "points": 3}, {"id": "LimitsCPU", "selector": "containers[] .resources .limits .cpu", "reason": "Enforcing CPU limits prevents DOS via resource exhaustion", "points": 1}, {"id": "LimitsMemory", "selector": "containers[] .resources .limits .memory", "reason": "Enforcing memory limits prevents DOS via resource exhaustion", "points": 1}, {"id": "RequestsCPU", "selector": "containers[] .resources .requests .cpu", "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "RequestsMemory", "selector": "containers[] .resources .requests .memory", "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster", "points": 1}, {"id": "CapDropAny", "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "points": 1}, {"id": "CapDropAll", "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")", "reason": "Drop all capabilities and add only those required to reduce syscall attack surface", "points": 1}, {"id": "ReadOnlyRootFilesystem", "selector": "containers[] .securityContext .readOnlyRootFilesystem == true", "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost", "points": 1}, {"id": "RunAsNonRoot", "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege", "points": 1}, {"id": "RunAsUser", "selector": "containers[] .securityContext .runAsUser -gt 10000", "reason": "Run as a high-UID user to avoid conflicts with the host's user table", "points": 1}], "advise": [{"id": "ApparmorAny", "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"", "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY", "points": 3}, {"id": "SeccompAny", "selector": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"", "reason": "Seccomp profiles set minimum privilege and secure against unknown threats", "points": 1}]}}], [{"object": "Namespace/kalm-benchmark.default", "valid": true, "fileName": "manifests/_kalm-benchmark-c882ce07.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "ResourceQuota/kalm-benchmark.default", "valid": true, "fileName": "manifests/_kalm-benchmark-c882ce07.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "LimitRange/kalm-benchmark.default", "valid": true, "fileName": "manifests/_kalm-benchmark-c882ce07.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}, {"object": "NetworkPolicy/kalm-benchmark.default", "valid": true, "fileName": "manifests/_kalm-benchmark-c882ce07.yaml", "message": "This resource kind is not supported by kubesec", "score": 0, "scoring": {}}]]